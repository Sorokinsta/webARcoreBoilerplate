<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.ar.js - Graffiti</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no,
  minimum-scale=1.0, maximum-scale=1.0">
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>
    <style>
        body {
            font-family: monospace;
            margin: 0;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100vh;
            -webkit-user-select: none;
            user-select: none;
        }
        #info {
            position: absolute;
            left: 50%;
            bottom: 0;
            transform: translate(-50%, 0);
            margin: 1em;
            z-index: 10;
            display: block;
            width: 100%;
            line-height: 2em;
            text-align: center;
        }
        #info * {
            color: #fff;
        }
        .title {
            background-color: rgba(40, 40, 40, 0.4);
            padding: 0.4em 0.6em;
            border-radius: 0.1em;
        }
        .links {
            background-color: rgba(40, 40, 40, 0.6);
            padding: 0.4em 0.6em;
            border-radius: 0.1em;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        .b-controls {
            position: absolute;
            left: 50%;
            top: 0;
            transform: translate(-50%, 0);
            margin: 1em;
            z-index: 100;
            display: block;
            width: 100%;
            line-height: 2em;
            text-align: center;
        }
        .b-controls button.c {
            opacity: 0.4;
            width: 45px;
            height: 45px;
            background-color: #9cdeff;
            border: 0;
            border-radius: 3px;
        }

        button{
            width: 300px;
            height: 40px;
        }
    </style>
</head>
<body>
<div class="b-controls" id="interf">
    <div>
        <h3>1</h3>
        <button class="c" id="arLeft">←</button>
        <button class="c" id="arTop">↑</button>
        <button class="c" id="arBottom">↓</button>
        <button class="c" id="arRight">→</button>
    </div>
    <div>
        <h3>взад вперед</h3>
        <button class="c" id="arCome">↑</button>
        <button class="c" id="arOut">↓</button>
    </div>

    <div>
        <h3>x</h3>
        <button class="c" id="rotateXRight">⤿</button>
        <button class="c" id="rotateXLeft">⤾</button>
        <h3>y</h3>
        <button class="c" id="rotateYRight">⤿</button>
        <button class="c" id="rotateYLeft">⤾</button>
        <h3>z</h3>
        <button class="c" id="rotateZRight">⤿</button>
        <button class="c" id="rotateZLeft">⤾</button>
    </div>
    <button style="margin-top: 10px" onclick="dis()">Установить</button>
</div>

<div id="info">

    <div id="buttons">
        <button id="now" onclick="now()">Настоящее</button>
        <button id="last" onclick="day(obj2,obj1)">Вчера</button>
        <button id="lastlast" onclick="day(obj1,obj2)">Позавчера</button>
    </div>
</div>
<script src="./lib/three.js/three.js"></script>
<script src="./lib/three.js/VRControls.js"></script>
<script src="./lib/three.js/OBJLoader.js"></script>
<script src="./lib/three.js/MTLLoader.js"></script>
<script src="./lib/dist/three.ar.js"></script>
<script src="./assets/jq.js"></script>
<script>



</script>
<script>
    var isObj1Setted = false;
    var isObj2Setted = false;
    var curObj;





    var vrDisplay;
    var vrControls;
    var arView;
    var canvas;
    var camera;
    var scene;
    var renderer;
    var obj1;
    var obj2;
    var shadowMesh;
    var planeGeometry;
    var light;
    var directionalLight;
    var OBJ1_PATH = './assets/realese2.obj';
    var MTL1_PATH = './assets/realese2.mtl';
    var OBJ2_PATH = './assets/ArcticFox_Posed.obj';
    var MTL2_PATH = './assets/ArcticFox_Posed.mtl';
    var SCALE = 0.1;
    /**
     * Use the `getARDisplay()` utility to leverage the WebVR API
     * to see if there are any AR-capable WebVR VRDisplays. Returns
     * a valid display if found. Otherwise, display the unsupported
     * browser message.
     */
    THREE.ARUtils.getARDisplay().then(function (display) {
        if (display) {
            vrDisplay = display;
            init();
        } else {
            THREE.ARUtils.displayUnsupportedMessage();
        }
    });
    function init() {

        // Setup the three.js rendering environment
        renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.autoClear = false;
        canvas = renderer.domElement;
        document.body.appendChild(canvas);
        scene = new THREE.Scene();
        // Creating the ARView, which is the object that handles
        // the rendering of the camera stream behind the three.js
        // scene
        arView = new THREE.ARView(vrDisplay, renderer);
        // The ARPerspectiveCamera is very similar to THREE.PerspectiveCamera,
        // except when using an AR-capable browser, the camera uses
        // the projection matrix provided from the device, so that the
        // perspective camera's depth planes and field of view matches
        // the physical camera on the device.
        camera = new THREE.ARPerspectiveCamera(
            vrDisplay,
            60,
            window.innerWidth / window.innerHeight,
            vrDisplay.depthNear,
            vrDisplay.depthFar
        );
        // VRControls is a utility from three.js that applies the device's
        // orientation/position to the perspective camera, keeping our
        // real world and virtual world in sync.
        vrControls = new THREE.VRControls(camera);
        // For shadows to work
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        // The materials in Poly models will render as a black mesh
        // without lights in our scenes. Let's add an ambient light
        // so our model can be scene, as well as a directional light
        // for the shadow
        directionalLight = new THREE.DirectionalLight();
        // @TODO in the future, use AR light estimation
        directionalLight.intensity = 0.3;
        directionalLight.position.set(10, 15, 10);
        // We want this light to cast shadow
        directionalLight.castShadow = true;
        light = new THREE.AmbientLight();
        scene.add(light);
        scene.add(directionalLight);
        // Make a large plane to receive our shadows
        planeGeometry = new THREE.PlaneGeometry(2000, 2000);
        // Rotate our plane to be parallel to the floor
        planeGeometry.rotateX(-Math.PI / 2);
        // Create a mesh with a shadow material, resulting in a mesh
        // that only renders shadows once we flip the `receiveShadow` property
        shadowMesh = new THREE.Mesh(planeGeometry, new THREE.ShadowMaterial({
            color: 0x111111,
            opacity: 0.015,
        }));
        shadowMesh.receiveShadow = true;
        scene.add(shadowMesh);
        THREE.ARUtils.loadModel({
            objPath: OBJ2_PATH,
            mtlPath: MTL2_PATH,
            OBJLoader: undefined, // uses window.THREE.OBJLoader by default
            MTLLoader: undefined, // uses window.THREE.MTLLoader by default
        }).then(function (group) {
            obj2 = group;
            // As OBJ models may contain a group with several meshes,
            // we want all of them to cast shadow
            obj2.children.forEach(function (mesh) {
                mesh.castShadow = true;
            });
            obj2.scale.set(SCALE, SCALE, SCALE);
            // Place the model very far to initialize
            obj2.position.set(0, 0, -3);

        }).catch(function (e) {
            alert("CATCH");
//      alert(JSON.stringify(e));
        });
        THREE.ARUtils.loadModel({
            objPath: OBJ1_PATH,
            mtlPath: MTL1_PATH,
            OBJLoader: undefined, // uses window.THREE.OBJLoader by default
            MTLLoader: undefined, // uses window.THREE.MTLLoader by default
        }).then(function (group) {
            obj1 = group;
            // As OBJ models may contain a group with several meshes,
            // we want all of them to cast shadow
            obj1.children.forEach(function (mesh) {
                mesh.castShadow = true;
            });
            obj1.scale.set(SCALE, SCALE, SCALE);
            // Place the model very far to initialize
            obj1.position.set(0, 0, -3);


        }).catch(function (e) {
            alert("CATCH");

//      alert(JSON.stringify(e));
        });

        // Bind our event handlers
        window.addEventListener('resize', onWindowResize, false);
        canvas.addEventListener('click', onClick, false);
        // Kick off the render loop!
        update();
    }
    /**
     * The render loop, called once per frame. Handles updating
     * our scene and rendering.
     */
    function update() {
        // Clears color from the frame before rendering the camera (arView) or scene.
        renderer.clearColor();
        // Render the device's camera stream on screen first of all.
        // It allows to get the right pose synchronized with the right frame.
        arView.render();
        // Update our camera projection matrix in the event that
        // the near or far planes have updated
        camera.updateProjectionMatrix();
        // Update our perspective camera's positioning
        vrControls.update();
        // Render our three.js virtual scene
        renderer.clearDepth();
        renderer.render(scene, camera);
        // Kick off the requestAnimationFrame to call this function
        // when a new VRDisplay frame is rendered
        vrDisplay.requestAnimationFrame(update);
    }
    /**
     * On window resize, update the perspective camera's aspect ratio,
     * and call `updateProjectionMatrix` so that we can get the latest
     * projection matrix provided from the device
     */
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    /**
     * When clicking on the screen, fire a ray from where the user clicked
     * on the screen and if a hit is found, place a cube there.
     */
    function onClick(e) {


    }

    function set() {
        alert("set");
    }


    function hide() {
            scene.remove(obj2);
            animate();
    }

    function show() {
            scene.add(obj2);
    }

    function day(lastObj,newObj) {

        curObj = newObj;


        if (curObj === obj1){
            if (isObj1Setted){
                $("#interf").hide();
            }else {
                $("#interf").show();
            }
        } else {
            if (isObj2Setted){
                $("#interf").hide();
            }else {
                $("#interf").show();
            }
        }

        scene.remove(lastObj);
        scene.add(newObj);
        animate();
    }


    function dis() {
        $("#interf").hide();
        if (curObj === obj1 ){
            isObj1Setted = true;
        } else {
            isObj2Setted = true;
        }
    }

    function now() {
        $("#interf").hide();
        scene.remove(curObj);
        animate();
    }

    var step = 0.1;
    var arLeft = document.getElementById("arLeft");
    var arTop = document.getElementById("arTop");
    var arBottom = document.getElementById("arBottom");
    var arRight = document.getElementById("arRight");
    var arOut = document.getElementById("arOut");
    var arCome = document.getElementById("arCome");
    var rotateXRight = document.getElementById("rotateXRight");
    var rotateXLeft = document.getElementById("rotateXLeft");
    var rotateYRight = document.getElementById("rotateYRight");
    var rotateYLeft = document.getElementById("rotateYLeft");
    var rotateZRight = document.getElementById("rotateZRight");
    var rotateZLeft = document.getElementById("rotateZLeft");
    arLeft.addEventListener('click', function () {
        curObj.position.set(curObj.position.x - step ,curObj.position.y,curObj.position.z);
    }, false);
    arTop.addEventListener('click', function () {
        curObj.position.set(curObj.position.x ,curObj.position.y + step,curObj.position.z);
    }, false);
    arBottom.addEventListener('click', function () {
        curObj.position.set(curObj.position.x ,curObj.position.y - step,curObj.position.z);
    }, false);
    arRight.addEventListener('click', function () {
        curObj.position.set(curObj.position.x + step ,curObj.position.y,curObj.position.z);
    }, false);
    arOut.addEventListener('click', function () {
        curObj.position.set(curObj.position.x,curObj.position.y,curObj.position.z + step);
    }, false);
    arCome.addEventListener('click', function () {
        curObj.position.set(curObj.position.x ,curObj.position.y,curObj.position.z - step);
    }, false);


    rotateXRight.addEventListener('click', function () {
        curObj.rotateX(0.2);
    }, false);
    rotateXLeft.addEventListener('click', function () {
        curObj.rotateX(-0.2);
    }, false);
    rotateYRight.addEventListener('click', function () {
        curObj.rotateY(0.2);
    }, false);
    rotateYLeft.addEventListener('click', function () {
        curObj.rotateY(-0.2);
    }, false);
    rotateZRight.addEventListener('click', function () {
        curObj.rotateZ(0.2);
    }, false);
    rotateZLeft.addEventListener('click', function () {
        curObj.rotateZ(-0.2);
    }, false);
</script>
</body>
</html>