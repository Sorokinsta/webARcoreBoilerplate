<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.ar.js - Graffiti</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no,
  minimum-scale=1.0, maximum-scale=1.0">

    <style>
        body {
            font-family: monospace;
            margin: 0;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100vh;
            -webkit-user-select: none;
            user-select: none;
        }

        #info {
            position: absolute;
            left: 50%;
            bottom: 0;
            transform: translate(-50%, 0);
            margin: 1em;
            z-index: 10;
            display: block;
            width: 100%;
            line-height: 2em;
            text-align: center;
            display: none;
        }

        #info * {
            color: #fff;
        }

        .title {
            background-color: rgba(40, 40, 40, 0.4);
            padding: 0.4em 0.6em;
            border-radius: 0.1em;
        }

        .links {
            background-color: rgba(40, 40, 40, 0.6);
            padding: 0.4em 0.6em;
            border-radius: 0.1em;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        :root {
            --bg-color: #274a60;
        }

        * {
            box-sizing: border-box;
        }

        .b-timeline {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            display: flex;
            flex-flow: row nowrap;
            background-color: var(--bg-color);
            padding: 5px;
            overflow: hidden;
        }

        .b-timeline__item {
            position: relative;
            width: 100%;
            height: 50px;
            overflow: hidden;
            color: white;
            font-family: SansSerif, sans-serif;
        }

        .b-timeline__item::before {
            content: '';
            position: absolute;
            top: 50%;
            transform: translate(0, -50%);
            border: 2.5px solid white;
            width: 100%;
        }

        .b-timeline__item button {
            width: 20px;
            height: 20px;
            background-color: #F44336;
            border: 5px solid var(--bg-color);
            transition: border-width 0.6s;
            box-sizing: border-box;
            border-radius: 100%;
            margin: 5px;
            padding: 0;
            margin: 0;
            position: relative;
            top: 50%;
            left: 10px;
            transform: translate(0, -50%);
        }

        .b-timeline__item.active button {
            width: 25px;
            height: 25px;
            background-color: greenyellow;
        }

        .b-timeline__item span {
        }
    </style>
</head>
<body>
<div class="b-timeline">
    <div class="b-timeline__item active b-timeline__item--w3 ">
        <button data-number="1"></button>
        <span>1.03.1881</span>
    </div>
    <div class="b-timeline__item b-timeline__item--w3">
        <button data-number="2"></button>
        <span>1943 год</span>
    </div>
    <div class="b-timeline__item b-timeline__item--w3">
        <button data-number="3"></button>
        <span>Сегодня</span>
    </div>
</div>
<script>
  var timeLineBtn = document.getElementById("timeLineBtn");
  var timeLineBtns = document.getElementsByClassName('b-timeline__item');

  for (i = 0; i < timeLineBtns.length; i++) {
    timeLineBtns[i].addEventListener("click", function (event) {
      if (event.target.type === 'submit') {
        var number = event.target.getAttribute('data-number');
        var parent = event.target.parentElement;
        var parents = document.getElementsByClassName('b-timeline__item');
        for (j = 0; j < parents.length; j++) {
          parents[j].classList.remove('active');
        }
        parent.classList.add("active");
      }
      else{
        var target = event.target;
        var parents = document.getElementsByClassName('b-timeline__item');
        for (j = 0; j < parents.length; j++) {
          parents[j].classList.remove('active');
        }
        target.classList.add("active");
      }
    }, false);
  }
</script>
<div id="info">
    <span class="title">Tap to spawn an object from <a
            href="https://poly.google.com">Poly</a>.</span><br/>
    <span class="title">
    <a href="https://poly.google.com/view/dK08uQ8-Zm9">Model</a> by
    <a href="https://poly.google.com/user/f8cGQY15_-g">Naomi Chen</a> /
    <a href="https://creativecommons.org/licenses/by/2.0/">CC-BY</a>
  </span><br/>
    <span class="links">
    <a href="https://github.com/google-ar/three.ar.js">three.ar.js</a> -
    <a href="https://developers.google.com/ar/develop/web/getting-started#examples">examples</a>
  </span>
</div>
<script src="./lib/three.js/three.js"></script>
<script src="./lib/three.js/VRControls.js"></script>
<script src="./lib/three.js/OBJLoader.js"></script>
<script src="./lib/three.js/MTLLoader.js"></script>
<script src="./lib/dist/three.ar.js"></script>
<!--<script src="./lib/greensock-js/src/minified/TimelineMax.min.js"></script>-->
<script src="./lib/greensock-js/src/minified/TweenLite.min.js"></script>
<script>
  var vrDisplay;
  var vrControls;
  var arView;
  var canvas;
  var camera;
  var scene;
  var renderer;
  var model1;
  var model2;
  var shadowMesh;
  var planeGeometry;
  var light;
  var directionalLight;
  var OBJ_PATH = './assets/CARRESIZE.obj';
  var MTL_PATH = './assets/CARRESIZE.mtl';
  var SCALE = 0.05;
  var gTime = 0;
  /**
   * Use the `getARDisplay()` utility to leverage the WebVR API
   * to see if there are any AR-capable WebVR VRDisplays. Returns
   * a valid display if found. Otherwise, display the unsupported
   * browser message.
   */
  THREE.ARUtils.getARDisplay().then(function (display) {
    if (display) {
      vrDisplay = display;
      init();
    } else {
      THREE.ARUtils.displayUnsupportedMessage();
    }
  });
  function init() {

    // Turn on the debugging panel
//    var arDebug = new THREE.ARDebug(vrDisplay);
//    document.body.appendChild(arDebug.getElement());
    // Setup the three.js rendering environment
    renderer = new THREE.WebGLRenderer({ alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.autoClear = false;
    canvas = renderer.domElement;
    document.body.appendChild(canvas);
    scene = new THREE.Scene();
    // Creating the ARView, which is the object that handles
    // the rendering of the camera stream behind the three.js
    // scene
    arView = new THREE.ARView(vrDisplay, renderer);
    // The ARPerspectiveCamera is very similar to THREE.PerspectiveCamera,
    // except when using an AR-capable browser, the camera uses
    // the projection matrix provided from the device, so that the
    // perspective camera's depth planes and field of view matches
    // the physical camera on the device.
    camera = new THREE.ARPerspectiveCamera(
        vrDisplay,
        60,
        window.innerWidth / window.innerHeight,
        vrDisplay.depthNear,
        vrDisplay.depthFar
    );
    // VRControls is a utility from three.js that applies the device's
    // orientation/position to the perspective camera, keeping our
    // real world and virtual world in sync.
    vrControls = new THREE.VRControls(camera);
    // For shadows to work
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    // The materials in Poly models will render as a black mesh
    // without lights in our scenes. Let's add an ambient light
    // so our model can be scene, as well as a directional light
    // for the shadow
    directionalLight = new THREE.DirectionalLight();
    // @TODO in the future, use AR light estimation
    directionalLight.intensity = 0.3;
    directionalLight.position.set(10, 15, 10);
    // We want this light to cast shadow
    directionalLight.castShadow = true;
    light = new THREE.AmbientLight();
    scene.add(light);
    scene.add(directionalLight);
    // Make a large plane to receive our shadows
    planeGeometry = new THREE.PlaneGeometry(2000, 2000);
    // Rotate our plane to be parallel to the floor
    planeGeometry.rotateX(-Math.PI / 2);
    // Create a mesh with a shadow material, resulting in a mesh
    // that only renders shadows once we flip the `receiveShadow` property
    shadowMesh = new THREE.Mesh(planeGeometry, new THREE.ShadowMaterial({
      color: 0x111111,
      opacity: 0.015,
    }));
    shadowMesh.receiveShadow = true;
    scene.add(shadowMesh);
    loadModal(1, './assets/myman.obj', './assets/myman.mtl', -5.0, -4.0, -5.0);
    loadModal(2, './assets/myman.obj', './assets/myman.mtl', 5.0, -4.0, -5.0);

    function loadModal(number, objPath, mtlPath, x, y, z) {
      THREE.ARUtils.loadModel({
        objPath: objPath,
        mtlPath: mtlPath
      }).then(function (group) {
        if (number === 1) {
          model1 = group;
          model1.children.forEach(function (mesh) {
            mesh.castShadow = true;
          });
          model1.scale.set(SCALE, SCALE, SCALE);
          model1.position.set(x, y, z);
          scene.add(model1);
        }
        if (number === 2) {
          model2 = group;
          model2.children.forEach(function (mesh) {
            mesh.castShadow = true;
          });
          model2.scale.set(SCALE, SCALE, SCALE);
          model2.position.set(x, y, z);
          scene.add(model2);
        }
      }).catch(function (e) {
        alert(JSON.stringify(e));
      });
    }

    // Bind our event handlers
    window.addEventListener('resize', onWindowResize, false);
    canvas.addEventListener('click', onClick, false);
    // Kick off the render loop!
    update();
  }
  /**
   * The render loop, called once per frame. Handles updating
   * our scene and rendering.
   */
  function update() {
    gTime += 1;
    // Clears color from the frame before rendering the camera (arView) or scene.
    renderer.clearColor();
    // Render the device's camera stream on screen first of all.
    // It allows to get the right pose synchronized with the right frame.
    arView.render();
    // Update our camera projection matrix in the event that
    // the near or far planes have updated
    camera.updateProjectionMatrix();
    // Update our perspective camera's positioning
    vrControls.update();
    // Render our three.js virtual scene
    renderer.clearDepth();
    renderer.render(scene, camera);
    // Kick off the requestAnimationFrame to call this function
    // when a new VRDisplay frame is rendered
    vrDisplay.requestAnimationFrame(update);
  }
  /**
   * On window resize, update the perspective camera's aspect ratio,
   * and call `updateProjectionMatrix` so that we can get the latest
   * projection matrix provided from the device
   */
  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }
  /**
   * When clicking on the screen, fire a ray from where the user clicked
   * on the screen and if a hit is found, place a cube there.
   */
  function onClick(e) {
    // Inspect the event object and generate normalize screen coordinates
    // (between 0 and 1) for the screen position.
    var x = e.clientX / window.innerWidth;
    var y = e.clientY / window.innerHeight;
    // Send a ray from the point of click to the real world surface
    // and attempt to find a hit. `hitTest` returns an array of potential
    // hits.
    var hits = vrDisplay.hitTest(x, y);
    if (!model1) {
      alert('Model not yet loaded');
      console.warn('Model not yet loaded');
      return;
    }
    // If a hit is found, just use the first one
    if (hits && hits.length) {
      var hit = hits[0];
      // Turn the model matrix from the VRHit into a
      // THREE.Matrix4 so we can extract the position
      // elements out so we can position the shadow mesh
      // to be directly under our model. This is a complicated
      // way to go about it to illustrate the process, and could
      // be done by manually extracting the "Y" value from the
      // hit matrix via `hit.modelMatrix[13]`
      var matrix = new THREE.Matrix4();
      var position = new THREE.Vector3();
      matrix.fromArray(hit.modelMatrix);
      position.setFromMatrixPosition(matrix);
      // Set our shadow mesh to be at the same Y value
      // as our hit where we're placing our model
      // @TODO use the rotation from hit.modelMatrix
      shadowMesh.position.y = position.y;
      // Use the `placeObjectAtHit` utility to position
      //alert(JSON.stringify(hit));
      // the cube where the hit occurred
//      THREE.ARUtils.placeObjectAtHit(model1,  // The object to place
//          hit,   // The VRHit object to move the cube to
//          1,     // Easing value from 0 to 1; we want to move
//          // the cube directly to the hit position
//          true); // Whether or not we also apply orientation

      // Rotate the model to be facing the user
//      var angle = Math.atan2(
//              camera.position.x - model1.position.x,
//              camera.position.z - model1.position.z
//          );
//      model1.rotation.set(0, angle, 0);
    }
  }

</script>
</body>
</html>